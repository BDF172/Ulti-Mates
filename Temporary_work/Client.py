import socket, threading, time
import end_to_end_encryption as e2ee
import traceback

global client_key
client_key = None

global handshake_done
handshake_done = False

global username
username = ""


def handshake(socket:socket.socket):
    """
    send the encryption key to the server, encryption key is generated by the client and encrypted by the fix token
    """
    
    global client_key

    print("\n> handshake en cours", end="")
    encryption_key = e2ee.generate_token()
  
    client_key = encryption_key
    encrypted_key = e2ee.encrypt_message(encryption_key, e2ee.fix_token)


    try :
        print(".", end="", flush=True)
        socket.send(encrypted_key)
    except Exception as e:
        print("\n/!\ Impossible d'effectuer le handshake ! /!\ \n")
        print(traceback.format_exc())
        return False

    print(".", end="", flush=True)

    try :
        response = socket.recv(1024)
        print(".", end="", flush=True)
        if e2ee.decrypt_message(response, e2ee.fix_token) == client_key:
            return True
        else:
            print("\n/!\ handshake échoué ! /!\ \n")
            return False
    except Exception as e:
        print("\n/!\ Impossible d'effectuer le handshake ! /!\ \n")
        print(traceback.format_exc())
        return False



def send_message(sock:socket.socket):
    """
    Send a message to the server
    -
    message is encrypted with the encryption key
    """
    global username

    while True :
        message = str(input())
        if message != '':
            if message == "/exit":
                sock.close()
                exit()

            if message == "/reconnect":
                sock.close()
                connect()

            if username == "":
                username = message

            print("\033[1A\033[2K\r", end="")
            print(f"<{username}> {message}")
            
            if len(message) >= 1024:
                print("\n> Message trop long !")
                continue
            
            try :
                sock.send(e2ee.encrypt_message(message, client_key))
            except Exception as e:
                print("\n/!\ Impossible d'envoyer le message ! /!\ \n")
                print(traceback.format_exc())
  
  
    
def receive_message(sock:socket.socket):
    """
    Receive a message from the server
    -
    message is decrypted with the encryption key
    """
    while True :
        try:
            if sock.fileno() == -1: return False

            encrypted_message = sock.recv(1024)
            message = e2ee.decrypt_message(encrypted_message, client_key)
            print(message)
        except OSError as e:
            print(f"/!\ Une erreur est survenue lors de la dernière réception de message: {e} /!\ \n")
            sock.close()
            disconnect(sock)



def disconnect(socket:socket.socket):
    print("> type '/reconnect' to attemps to reconnect, or '/exit' to quite")
    reco = str(input('> '))
    if reco == "/reconnect":
        socket.close()
        connect()
    elif reco == '/exit': exit()
    else: print("> commande inconnu")



def connect():

    global handshake_done

    connected = False

    if not connected:

        # host = str(input("Adresse IP du serveur : "))
        # port = int(input("Port du serveur : "))

        host="91.173.148.254"
        host="127.0.0.1"

        port = 24444
        port = 4444

        print("\n> connexion au serveur", end="")
        try:
            print(".", end="", flush=True)
            sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

            print(".", end="", flush=True)
            sock.connect((host,port))
            
            print(".", end="", flush=True)
            connected = True
        except:
            print('\n')
            print("\n/!\ Impossible de se connecter au serveur ! /!\  \n  |-> Vérifiez que le serveur est bien en ligne et que vous avez entré la bonne adresse IP et le bon port !\n ")
    
        if connected:

            send_thread = threading.Thread(target=send_message, args=(sock,))
            receive_thread = threading.Thread(target=receive_message, args=(sock,))

            handshake_done = handshake(sock)

            if handshake_done:
                print("\n> handshake réussi !\n")
            else:
                print("\n/!\ cryptage de la connexion impossible ! /!\ \n")
                sock.close()
                disconnect(sock)
                connected = False

            if handshake_done :
                print("\n> cryptage de la connexion établie !\nVous pouvez commencer à envoyer des messages en toute sécurité !\n--Début de l'authentification--\n")
                connected = True

            send_thread.start()
            receive_thread.start()

        if not connected:
            print("\n/!\ connexion error /!\ \n")
            sock.close()
            disconnect(sock)



connect()